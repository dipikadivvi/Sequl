-- regex 
/*
*	Zero or more instances of string preceding it
+	One or more instances of strings preceding it
.	Any single character
?	Match zero or one instances of the strings preceding it.
^	caret(^) matches Beginning of string
$	End of string
[abc]	Any character listed between the square brackets
[^abc]	Any character not listed between the square brackets
[A-Z]	match any upper case letter.
[a-z]	match any lower case letter
[0-9]	match any digit from 0 through to 9.
[[:<:]]	matches the beginning of words.
[[:>:]]	matches the end of words.
[:class:]	matches a character class i.e. [:alpha:] to match letters, [:space:] to match white space, [:punct:] is match punctuations and [:upper:] for upper class letters.
p1|p2|p3	Alternation; matches any of the patterns p1, p2, or p3
{n}	Exactly n instances of preceding element
{m,n}	between m and n instances of preceding element
*/

#'strings'
-----
select title from sakila.film; 

SELECT title, LPAD(RPAD(title, 20, '*'),25,'*') AS left_padded
FROM sakila.film
LIMIT 5;

SELECT title, LPAD(title, 20, '*') AS left_padded
FROM sakila.film
LIMIT 5;

-----------------------------------------
#Substring  to find the string within a string. like finding short titles from big ones.alter
# substring('where to search', 'starting position','how many position')
SELECT title, SUBSTRING(title, 1,9)  AS short_title 
FROM sakila.film;

----------------------
#concatination

SELECT CONCAT(first_name, '.', last_name) AS full_name 
FROM sakila.customer;
--------------------------
SELECT title, REVERSE(title) AS reversed_title
FROM sakila.film
LIMIT 5;

------------------------------
#length 

SELECT title, LENGTH(title) AS title_length 
FROM sakila.film
WHERE LENGTH(title) =8;
-------------------------------------
#substring with locate 
select email from sakila.customer;
# LOCATE(substring, string, [start_position])
# SUBSTRING(input_string, start_position, length)
SELECT email,
       SUBSTRING(email, LOCATE('@', email) +1) AS domain
FROM sakila.customer;
-- I DON'T UNDERSTAND THE LOCATE SYNTAX POSITION VALUE
select email, substring(email,+5) AS domain from sakila.customer;


SELECT 
  email,
  substring_index(SUBSTRING(email, LOCATE('@', email) + 1), '.', -1) AS domain
FROM 
  sakila.customer;
  
  SELECT 
  email,
  substring_index(SUBSTRING(email, LOCATE('@', email) + 1),'a',2) AS domain
FROM 
  sakila.customer;
  

#substring_index gives the value after or before the seperation string. -1 gives one side value and +1 gives otherside
-- substring extracts portion of a string based on position and length, where as
-- substring index extracts portion of a string based on the occurance of a specified delimeter
select substring_index(email,'@', 1) from sakila.customer;

--------------------------
SELECT title, UPPER(title),lower(title)
FROM sakila.film
WHERE UPPER(title) LIKE '%LOVELY%' or UPPER(title) LIKE '%MAN';

select title, lower(title) as lower_titles
FROM sakila.film;
--------------------------------------------------
SELECT LEFT(title, 3) AS first_letter, right(title,3) as last_letter,  COUNT(*) AS film_count
FROM sakila.film
GROUP BY LEFT(title, 3), right(title,3)
ORDER BY film_count DESC;
-----
SELECT LEFT(title,2) AS first_letter, right(title, 3) as last_letter, title 
from sakila.film;

-------------------
SELECT last_name,
       CASE 
           WHEN LEFT(last_name, 1) BETWEEN 'A' AND 'M' THEN 'Group A-M'
           WHEN LEFT(last_name, 1) BETWEEN 'N' AND 'Z' THEN 'Group N-Z'
           ELSE 'Other'
       END AS group_label
FROM sakila.customer;

---------------

select last_name,
case
when left(last_name,1) between 'A' and 'P' then 'GROUP A-P'
when left(last_name,1) between 'Q' and 'Z' then 'GROUP Q-Z'
ELSE 'other'
END AS group_label
FROM sakila.customer;

SELECT title, REPLACE(title, 'A', 'x') AS cleaned_title
FROM sakila.film
WHERE title LIKE '%';
 

-----------------
# regex is used for pattern matching or string matching.
-- Standard SQL expressions are used for simple pattern matching and string comparisions. where as
-- regular expressions(REGEX/REGEXP) provide powerful, highly flexible method for complex pattern matching 
-- not contains 3 consecutive vowels 
SELECT customer_id, last_name
FROM sakila.customer
WHERE last_name REGEXP '[^aeiouAEIOU]{3}'; 

-- ends with vowel
SELECT lower(title)
FROM sakila.film
WHERE title REGEXP '[aeiouAEIOU]$';

-- titles ending with  either e or E.
select title, left	(title,2)
FROM sakila.film
WHERE title REGEXP '[eE]$' 
;

-- count 
-- how many titles End with Vowel sound.
select right(title,1), count(*)
FROM sakila.film
WHERE title REGEXP '[aeiouAEIOU]$' 
group by right(title,1)
;

-- titles ending with e or E
SELECT title AS ending, right(title,1)
FROM sakila.film
WHERE title REGEXP '[Ee]$';

-- count of titles starting with vowel sounds.

select left(title,1),count(*) from sakila.film
where title REGEXP '^[aeiouAEIOU].*'
group by left(title,1);

--------------------------------
#math 

SELECT title, rental_rate, rental_rate ^ 1 AS double_rate   -- debug why its allwoing string + integer
FROM sakila.film;
------------------------
---------------
#math 

-- select amount,CAST(amount AS signed) AS amount_str from sakila.payment;  -- check type casting in mysql 

-- for average total amount paid(sum of the amount) divided by how many payments(count) 
SELECT customer_id,
       COUNT(payment_id) AS payments,
       SUM(amount) AS total_paid,
       SUM(amount) / COUNT(payment_id) AS avg_payment
       
FROM sakila.payment
GROUP BY customer_id;
------------
select rental_duration,cost_efficiency_dup1 from sakila.film;

select rental_duration from sakila.film;


ALTER TABLE sakila.film
ADD COLUMN cost_efficiency_dup1 DECIMAL(6,2);


SET SQL_SAFE_UPDATES = 0;

UPDATE sakila.film
SET cost_efficiency_dup1 = rental_duration * 2
WHERE length IS NOT NULL;


select * from sakila.film;
---------------------------------
-- rand() will generate random number between 0-1 and floor is always rounding down. 
SELECT customer_id, (RAND() * 100), FLOOR(RAND() * 100) AS random_score
FROM sakila.customer
LIMIT 5;


----
SELECT film_id,rental_duration, POWER(rental_duration, 2) AS squared_duration
FROM sakila.film
LIMIT 5;

------
-- mod function gives the remainder value
SELECT film_id,length, MOD(length, 60) AS minutes_over_hour
FROM sakila.film;
-------------
SELECT rental_rate, CEIL(rental_rate) AS ceil_value, FLOOR(rental_rate) AS floor_value
FROM sakila.film;
----------
SELECT rental_rate, ROUND(replacement_cost / rental_rate, 0),ROUND(replacement_cost / rental_rate, 1) AS ratio
FROM sakila.film;

---------------------------------
#date diff 

SELECT rental_id, return_date,rental_date, DATEDIFF(return_date, rental_date) AS days_rented
FROM sakila.rental
WHERE return_date IS NOT NULL;

#date time 

select last_update,dayname(last_update),monthname(last_update) from sakila.film;
select last_update,day(last_update),month(last_update), date(last_update)from sakila.film;
SELECT 
    rental_date, year(rental_date)
FROM
   sakila.rental;


SELECT payment_date FROM sakila.payment;

SELECT payment_date, date(payment_date) AS pay_date, SUM(amount) AS total_paid
FROM sakila.payment
GROUP BY DATE(payment_date),payment_date
ORDER BY pay_date DESC;

#Find Customers Who Paid in the Last 24 Hours

select * from sakila.payment;

SELECT customer_id, amount, payment_date
FROM sakila.payment
WHERE payment_date <= NOW() - INTERVAL 1 DAY;

select max(payment_date) FROM sakila.payment;

SELECT customer_id, amount, payment_date
FROM sakila.payment
WHERE payment_date >= (
    SELECT MAX(payment_date) - INTERVAL 10 day
    FROM sakila.payment
);

select now()  - INTERVAL 1 DAY as yesterday;


SELECT CONCAT('Today is: ', CURDATE()) AS message;
SELECT CONCAT('Today is: ', now()) AS message;

SELECT NOW(), CURDATE(), CURRENT_TIME;

--------------------------------------------------------
#casting 

ALTER TABLE sakila.payment
ADD COLUMN amount_str VARCHAR(20);

SET SQL_SAFE_UPDATES = 0;

UPDATE sakila.payment
SET amount_str = CAST(amount AS CHAR);


select * from sakila.customer;

select * from sakila.payment;

ALTER TABLE sakila.payment
drop COLUMN amount_str;


----------------
SELECT amount, amount_Str, amount + 10 AS numeric_add,
       amount_str + 10 AS string_add
FROM sakila.payment
LIMIT 5;
-------------
-- cast changes the data type. from int to string or datetime to date
SHOW COLUMNS FROM sakila.payment;
SELECT CAST('2017-08-25' AS datetime);
---------------


